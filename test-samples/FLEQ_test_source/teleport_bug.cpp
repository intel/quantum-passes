#include <clang/Quantum/quintrinsics.h>
#include <clang/Quantum/qexpr.h>

// This bug demonstrated two different problems:
// First, the reversing of direction for binds and joins meant that IR generation
// put instructions in an order such that LLVM optimizations did not recoginze that
// that the use of measurements by "bob" were dependent on the measurements being 
// populated by "alice". Thus the initialization of the measurement bits was being
// propogated to the conditional, resulting in no branching being generated by FLEQ.
// Once the was resolved, it was also found that classical instructions attached to 
// binds where not beinghandling properly. In this case, the instruction for loading
// the measurement results from "alice" and passing them to "bob" were being inserted
// at the begin of the eval_hold call instead of between the QBBs represnting "alice"
// and "bob". 

// Prepare a Bell00 state |00> + |11>.
PROTECT QExpr bell00(qbit& a, qbit& b) {
    return qexpr::_PrepZ(a)
         + qexpr::_PrepZ(b)
         + qexpr::_H(a)
         + qexpr::_CNOT(a,b);
}


// Entangle q and a and measure both, writing the results to x and y
// respectively.
PROTECT QExpr alice(qbit& q, qbit& a, bool& x, bool& y) {
    return qexpr::_CNOT(q, a)
         + qexpr::_H(q)
         + qexpr::_MeasZ(q, x)
         + qexpr::_MeasZ(a, y);
}

// Use x and y to apply corrections to the qubit b.
PROTECT QExpr bob(qbit& b, bool &x, bool &y) {
    return qexpr::cIf(y, qexpr::_X(b), qexpr::identity())
         + qexpr::cIf(x, qexpr::_Z(b), qexpr::identity());
}

QExpr teleport1_join(qbit& q, qbit& a, qbit& b) {
    bool x = false;
    bool y = false;
    return bell00(a,b)
            + alice(q, a, x, y)
            + bob(b,x,y);
}

QExpr teleport1_bind(qbit& q, qbit& a, qbit& b) {
    bool x = false;
    bool y = false;
    return (bell00(a,b) + alice(q, a, x, y))
            << bob(b,x,y);
}

double getAngle();

void teleport1_bind() {

    qbit q;
    qbit a;
    qbit b;

    qexpr::eval_hold((qexpr::_PrepZ(q) + qexpr::_RX(q, getAngle())) // prepare |phi>
                    << teleport1_bind(q,a,b));

}