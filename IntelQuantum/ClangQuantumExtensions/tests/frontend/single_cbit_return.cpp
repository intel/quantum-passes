// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 3
// RUN: %clang -S -emit-llvm %include_dirs %loadintelclangextensions  %s -o - | FileCheck %s --dump-input fail


/// Development mode
#include "clang/Quantum/quintrinsics.h"

//#include <quantum.hpp>
#include <iostream>
#include <cassert>
#include <algorithm>

// Allocate 2 global qubits.
const int N = 2;
qbit qumem[N];
cbit c[N];


// CHECK-LABEL: define dso_local noundef zeroext i1 @_Z13Prep_and_Measv(
// CHECK-SAME: ) #[[ATTR0:[0-9]+]] section ".qbbs_text" {
// CHECK:    call void @_Z5PrepZRt(ptr noundef nonnull align 2 dereferenceable(2) getelementptr inbounds ([2 x i16], ptr @qumem, i64 0, i64 1))
// CHECK-NEXT:    call void @_Z5PrepZRt(ptr noundef nonnull align 2 dereferenceable(2) @qumem)
// CHECK-NEXT:    call void @_Z1XRt(ptr noundef nonnull align 2 dereferenceable(2) getelementptr inbounds ([2 x i16], ptr @qumem, i64 0, i64 1))
// CHECK-NEXT:    call void @_Z5MeasZRtRbb(ptr noundef nonnull align 2 dereferenceable(2) getelementptr inbounds ([2 x i16], ptr @qumem, i64 0, i64 1), ptr noundef nonnull align 1 dereferenceable(1) @c, i1 noundef zeroext false)
// CHECK-NEXT:    call void @_Z5MeasZRtRbb(ptr noundef nonnull align 2 dereferenceable(2) @qumem, ptr noundef nonnull align 1 dereferenceable(1) getelementptr inbounds ([2 x i8], ptr @c, i64 0, i64 1), i1 noundef zeroext false)
// CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr @c, align 1
// CHECK-NEXT:    [[TOBOOL:%.*]] = trunc i8 [[TMP0]] to i1
// CHECK-NEXT:    ret i1 [[TOBOOL]]
//
quantum_kernel cbit Prep_and_Meas()
{
    PrepZ(qumem[1]);
    PrepZ(qumem[0]);
    X(qumem[1]);
    MeasZ(qumem[1], c[0]);
    MeasZ(qumem[0], c[1]);
    return c[0];
}

// CHECK-LABEL: define dso_local noundef i32 @main(
// CHECK-SAME: ) #[[ATTR5:[0-9]+]] {
// CHECK:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[C:%.*]] = alloca i8, align 1
// CHECK-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef zeroext i1 @_Z13Prep_and_Measv()
// CHECK-NEXT:    [[FROMBOOL:%.*]] = zext i1 [[CALL]] to i8
// CHECK-NEXT:    store i8 [[FROMBOOL]], ptr [[C]], align 1
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(ptr noundef nonnull align 8 dereferenceable(8) @_ZSt4cout, ptr noundef @.str.25)
// CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[C]], align 1
// CHECK-NEXT:    [[TOBOOL:%.*]] = trunc i8 [[TMP0]] to i1
// CHECK-NEXT:    [[CALL2:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSolsEb(ptr noundef nonnull align 8 dereferenceable(8) [[CALL1]], i1 noundef zeroext [[TOBOOL]])
// CHECK-NEXT:    [[CALL3:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSolsEPFRSoS_E(ptr noundef nonnull align 8 dereferenceable(8) [[CALL2]], ptr noundef @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
// CHECK-NEXT:    ret i32 0
//
int main()
{
//    iqsdk::IqsConfig iqs_config;
//    iqsdk::FullStateSimulator iqs_device(iqs_config);
//    iqsdk::QRT_ERROR_T status = iqs_device.ready();
//    assert(status == iqsdk::QRT_ERROR_SUCCESS);
    cbit c = Prep_and_Meas();
    std::cout << "cbit is " << (bool) c << std::endl;

    return 0;

}

