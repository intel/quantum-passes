// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 3
// RUN: %clang -S -emit-llvm %include_dirs %loadintelclangextensions  %s -o - | FileCheck %s --dump-input fail


#include "clang/Quantum/quintrinsics.h"

const unsigned N = 5;
qbit q[N];

// CHECK-LABEL: define dso_local void @_Z10nestedLoopv(
// CHECK-SAME: ) #[[ATTR0:[0-9]+]] section ".qbbs_text" {
// CHECK:    [[I:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[J:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 0, ptr [[I]], align 4
// CHECK-NEXT:    br label %[[FOR_COND:.*]]
// CHECK:       [[FOR_COND]]:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[TMP0]], 5
// CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY:.*]], label %[[FOR_END8:.*]]
// CHECK:       [[FOR_BODY]]:
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], 1
// CHECK-NEXT:    store i32 [[ADD]], ptr [[J]], align 4
// CHECK-NEXT:    br label %[[FOR_COND1:.*]]
// CHECK:       [[FOR_COND1]]:
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[J]], align 4
// CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[TMP2]], 5
// CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY3:.*]], label %[[FOR_END:.*]]
// CHECK:       [[FOR_BODY3]]:
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP3]] to i64
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [5 x i16], ptr @q, i64 0, i64 [[IDXPROM]]
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr [[J]], align 4
// CHECK-NEXT:    [[IDXPROM4:%.*]] = sext i32 [[TMP4]] to i64
// CHECK-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds [5 x i16], ptr @q, i64 0, i64 [[IDXPROM4]]
// CHECK-NEXT:    call void @_Z4CNOTRtS_(ptr noundef nonnull align 2 dereferenceable(2) [[ARRAYIDX]], ptr noundef nonnull align 2 dereferenceable(2) [[ARRAYIDX5]])
// CHECK-NEXT:    br label %[[FOR_INC:.*]]
// CHECK:       [[FOR_INC]]:
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr [[J]], align 4
// CHECK-NEXT:    [[INC:%.*]] = add nsw i32 [[TMP5]], 1
// CHECK-NEXT:    store i32 [[INC]], ptr [[J]], align 4
// CHECK-NEXT:    br label %[[FOR_COND1]], !llvm.loop [[LOOP6:![0-9]+]]
// CHECK:       [[FOR_END]]:
// CHECK-NEXT:    br label %[[FOR_INC6:.*]]
// CHECK:       [[FOR_INC6]]:
// CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr [[I]], align 4
// CHECK-NEXT:    [[INC7:%.*]] = add nsw i32 [[TMP6]], 1
// CHECK-NEXT:    store i32 [[INC7]], ptr [[I]], align 4
// CHECK-NEXT:    br label %[[FOR_COND]], !llvm.loop [[LOOP8:![0-9]+]]
// CHECK:       [[FOR_END8]]:
// CHECK-NEXT:    ret void
//
quantum_kernel void nestedLoop() {
    for (int i = 0; i < N; i++) {
        for (int j = i + 1; j < N; j++) {
            CNOT(q[i], q[j]);
        }
    }
}































