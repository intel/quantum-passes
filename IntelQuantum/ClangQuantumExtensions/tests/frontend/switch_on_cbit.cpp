// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 3
// RUN: %clang -S -emit-llvm %include_dirs %loadintelclangextensions  %s -o - | FileCheck %s --dump-input fail


/// Development mode
#include "clang/Quantum/quintrinsics.h"

//#include <quantum.hpp>
#include <iostream>
#include <cassert>
#include <algorithm>

// Allocate 2 global qubits.
const int N = 2;
qbit qumem[N];


// CHECK-LABEL: define dso_local void @_Z13Prep_and_MeasPtPb(
// CHECK-SAME: ptr noundef [[Q:%.*]], ptr noundef [[C:%.*]]) #[[ATTR0:[0-9]+]] section ".qbbs_text" {
// CHECK:    [[Q_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[Q]], ptr [[Q_ADDR]], align 8
// CHECK-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[Q_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i16, ptr [[TMP0]], i64 1
// CHECK-NEXT:    call void @_Z5PrepZRt(ptr noundef nonnull align 2 dereferenceable(2) [[ARRAYIDX]])
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[Q_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i16, ptr [[TMP1]], i64 0
// CHECK-NEXT:    call void @_Z5PrepZRt(ptr noundef nonnull align 2 dereferenceable(2) [[ARRAYIDX1]])
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[Q_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i16, ptr [[TMP2]], i64 1
// CHECK-NEXT:    call void @_Z1XRt(ptr noundef nonnull align 2 dereferenceable(2) [[ARRAYIDX2]])
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[Q_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds i16, ptr [[TMP3]], i64 1
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[C_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[TMP4]], i64 0
// CHECK-NEXT:    call void @_Z5MeasZRtRbb(ptr noundef nonnull align 2 dereferenceable(2) [[ARRAYIDX3]], ptr noundef nonnull align 1 dereferenceable(1) [[ARRAYIDX4]], i1 noundef zeroext false)
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[Q_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds i16, ptr [[TMP5]], i64 0
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[C_ADDR]], align 8
// CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds i8, ptr [[TMP6]], i64 1
// CHECK-NEXT:    call void @_Z5MeasZRtRbb(ptr noundef nonnull align 2 dereferenceable(2) [[ARRAYIDX5]], ptr noundef nonnull align 1 dereferenceable(1) [[ARRAYIDX6]], i1 noundef zeroext false)
// CHECK-NEXT:    ret void
//
quantum_kernel void Prep_and_Meas(qbit q[], cbit c[])
{
    PrepZ(q[1]);
    PrepZ(q[0]);
    X(q[1]);
    MeasZ(q[1], c[0]);
    MeasZ(q[0], c[1]);
}

// CHECK-LABEL: define dso_local void @_Z10run_kernelPb(
// CHECK-SAME: ptr noundef [[C:%.*]]) #[[ATTR0]] section ".qbbs_text" {
// CHECK:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[C_ADDR]], align 8
// CHECK-NEXT:    call void @_Z13Prep_and_MeasPtPb(ptr noundef @qumem, ptr noundef [[TMP0]])
// CHECK-NEXT:    ret void
//
quantum_kernel void run_kernel(cbit c[])
{
    Prep_and_Meas(qumem, c);
}

// CHECK-LABEL: define dso_local noundef i32 @main(
// CHECK-SAME: ) #[[ATTR5:[0-9]+]] {
// CHECK:    [[RETVAL:%.*]] = alloca i32, align 4
// CHECK-NEXT:    [[CMEM:%.*]] = alloca [2 x i8], align 1
// CHECK-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK-NEXT:    store i32 0, ptr [[RETVAL]], align 4
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [2 x i8], ptr [[CMEM]], i64 0, i64 0
// CHECK-NEXT:    call void @_Z10run_kernelPb(ptr noundef [[ARRAYDECAY]])
// CHECK-NEXT:    store i64 0, ptr [[I]], align 8
// CHECK-NEXT:    br label %[[FOR_COND:.*]]
// CHECK:       [[FOR_COND]]:
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr [[I]], align 8
// CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TMP0]], 2
// CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY:.*]], label %[[FOR_END:.*]]
// CHECK:       [[FOR_BODY]]:
// CHECK-NEXT:    [[TMP1:%.*]] = load i64, ptr [[I]], align 8
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x i8], ptr [[CMEM]], i64 0, i64 [[TMP1]]
// CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr [[ARRAYIDX]], align 1
// CHECK-NEXT:    [[TOBOOL:%.*]] = trunc i8 [[TMP2]] to i1
// CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[TOBOOL]] to i32
// CHECK-NEXT:    switch i32 [[CONV]], label %[[SW_DEFAULT:.*]] [
// CHECK-NEXT:    i32 1, label %[[SW_BB:.*]]
// CHECK-NEXT:    i32 0, label %[[SW_BB4:.*]]
// CHECK-NEXT:    ]
// CHECK:       [[SW_BB]]:
// CHECK-NEXT:    [[CALL:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(ptr noundef nonnull align 8 dereferenceable(8) @_ZSt4cout, ptr noundef @.str.25)
// CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr [[I]], align 8
// CHECK-NEXT:    [[CALL1:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSolsEm(ptr noundef nonnull align 8 dereferenceable(8) [[CALL]], i64 noundef [[TMP3]])
// CHECK-NEXT:    [[CALL2:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(ptr noundef nonnull align 8 dereferenceable(8) [[CALL1]], ptr noundef @.str.26)
// CHECK-NEXT:    [[CALL3:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSolsEPFRSoS_E(ptr noundef nonnull align 8 dereferenceable(8) [[CALL2]], ptr noundef @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
// CHECK-NEXT:    br label %[[SW_EPILOG:.*]]
// CHECK:       [[SW_BB4]]:
// CHECK-NEXT:    [[CALL5:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(ptr noundef nonnull align 8 dereferenceable(8) @_ZSt4cout, ptr noundef @.str.25)
// CHECK-NEXT:    [[TMP4:%.*]] = load i64, ptr [[I]], align 8
// CHECK-NEXT:    [[CALL6:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSolsEm(ptr noundef nonnull align 8 dereferenceable(8) [[CALL5]], i64 noundef [[TMP4]])
// CHECK-NEXT:    [[CALL7:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(ptr noundef nonnull align 8 dereferenceable(8) [[CALL6]], ptr noundef @.str.27)
// CHECK-NEXT:    [[CALL8:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSolsEPFRSoS_E(ptr noundef nonnull align 8 dereferenceable(8) [[CALL7]], ptr noundef @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
// CHECK-NEXT:    br label %[[SW_EPILOG]]
// CHECK:       [[SW_DEFAULT]]:
// CHECK-NEXT:    [[CALL9:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(ptr noundef nonnull align 8 dereferenceable(8) @_ZSt4cout, ptr noundef @.str.25)
// CHECK-NEXT:    [[TMP5:%.*]] = load i64, ptr [[I]], align 8
// CHECK-NEXT:    [[CALL10:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSolsEm(ptr noundef nonnull align 8 dereferenceable(8) [[CALL9]], i64 noundef [[TMP5]])
// CHECK-NEXT:    [[CALL11:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(ptr noundef nonnull align 8 dereferenceable(8) [[CALL10]], ptr noundef @.str.28)
// CHECK-NEXT:    [[CALL12:%.*]] = call noundef nonnull align 8 dereferenceable(8) ptr @_ZNSolsEPFRSoS_E(ptr noundef nonnull align 8 dereferenceable(8) [[CALL11]], ptr noundef @_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_)
// CHECK-NEXT:    br label %[[SW_EPILOG]]
// CHECK:       [[SW_EPILOG]]:
// CHECK-NEXT:    br label %[[FOR_INC:.*]]
// CHECK:       [[FOR_INC]]:
// CHECK-NEXT:    [[TMP6:%.*]] = load i64, ptr [[I]], align 8
// CHECK-NEXT:    [[INC:%.*]] = add i64 [[TMP6]], 1
// CHECK-NEXT:    store i64 [[INC]], ptr [[I]], align 8
// CHECK-NEXT:    br label %[[FOR_COND]], !llvm.loop [[LOOP6:![0-9]+]]
// CHECK:       [[FOR_END]]:
// CHECK-NEXT:    ret i32 0
//
int main()
{
    cbit cmem[N];
    //iqsdk::IqsConfig iqs_config;
    //iqsdk::FullStateSimulator iqs_device(iqs_config);
    //iqsdk::QRT_ERROR_T status = iqs_device.ready();
    //assert(status == iqsdk::QRT_ERROR_SUCCESS);
    run_kernel(cmem);
    for (size_t i = 0; i < N; ++i)
    {
        switch(cmem[i])
        {
	    case true:
	          std::cout << "cbit " << i << " is true" << std::endl;
	          break;
	    case false:
	          std::cout << "cbit " << i << " is false" << std::endl;
	          break;
	    default:
	          std::cout << "cbit " << i << " is neither true or false" << std::endl;
	          break;
        }
    }

    return 0;

}



























